<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从0到1搭建个人博客</title>
      <link href="/2023/08/09/20200915-blog/"/>
      <url>/2023/08/09/20200915-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文意在帮助开发同学快速、高效的搭建个人博客；</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>node、hexo、腾讯云 Serverless Framework（ssr、云函数、云托管、cos 等）；</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote><p>首先在自己的 github 中创建一个同名的.github.io 的仓库（如：github 名为 test，就需要创建一个名为 test.github.io 的仓库）；</p></blockquote><p>全局安装 hexo 命令行工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>初始化项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ hexo init <span class="built_in">test</span> <span class="comment"># test是项目的名称，自定义；</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span> <span class="comment"># test是项目的名称，自定义；</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>初始化完成后，会自动生成一个项目，目录结构长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml &#x2F;&#x2F; 项目配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds &#x2F;&#x2F; 博客模板文件</span><br><span class="line">├── source &#x2F;&#x2F; 协作主体文件</span><br><span class="line">|   ├── _drafts &#x2F;&#x2F; 草稿文件</span><br><span class="line">|   └── _posts &#x2F;&#x2F; 文章文件，所有文章都放在这里面即可</span><br><span class="line">└── themes &#x2F;&#x2F; 博客皮肤主体文件，更换博客皮肤时用到</span><br></pre></td></tr></table></figure><p>配置</p><p>我们可以在_config.yml 文件中<a href="https://hexo.io/zh-cn/docs/configuration">配置</a>博客的基本信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&quot;辰总的blog&quot;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&quot;个人博客，技术文章，生活随笔，记录优秀的文章&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;JavaScript、Node、Vue、React、生活随笔、记录优秀的文章&quot;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&quot;JavaScript、Node、Vue、React、生活随笔、记录优秀的文章&quot;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">lgc</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-cmn-Hans</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br></pre></td></tr></table></figure><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>我们写文章主要是在_posts 目录下,_drafts 是草稿目录，如果文章不想被发表，可暂时存放到这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── source &#x2F;&#x2F; 协作主体文件</span><br><span class="line">|   ├── _drafts &#x2F;&#x2F; 草稿文件</span><br><span class="line">|   └── _posts &#x2F;&#x2F; 文章文件，所有文章都放在这里面即可</span><br></pre></td></tr></table></figure><p>layout 布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 <a href="https://github.com/node-swig/swig-templates">Swig</a> 模板引擎，您可以另外安装插件来获得 <a href="https://github.com/hexojs/hexo-renderer-ejs">EJS</a>、<a href="https://github.com/hexojs/hexo-renderer-haml">Haml</a>、<a href="https://github.com/hexojs/hexo-renderer-jade">Jade</a> 或 <a href="https://github.com/maxknee/hexo-render-pug">Pug</a> 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout.ejs   - 使用 EJS</span><br><span class="line">layout.swig  - 使用 Swig</span><br></pre></td></tr></table></figure><p>执行 hexo server 启动 hexo 本地服务器，可以看到项目生成了一个 demo 文章（hexo server -p xxxx，可自定义端口）：</p><p><em>所有文章的写作使用的是<a href="https://www.runoob.com/markdown/md-tutorial.html">markdown</a>语法，文件名最好是日期-文章内容的方式（如：20200915-blog.md），后缀名是.md；</em></p><p><img src="/assets/20200915-blog/img1.png" alt="image-20200911172630511"></p><p>Front-matter</p><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">大家好</span> <span class="string">//</span> <span class="string">页面的标题</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">aaa</span> <span class="string">//</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bbb</span> <span class="string">//</span> <span class="string">文章标签</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ccc</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">...other</span> <span class="string">code</span></span><br></pre></td></tr></table></figure><p>可以看到页面中的标题，分类都加上了</p><p><img src="/assets/20200915-blog/img2.png" alt="image-20200911172630511"></p><p>常用的变量列表如下：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">layout</td><td align="center">布局</td><td align="center"></td></tr><tr><td align="center">title</td><td align="center">标题</td><td align="center">文章的文件名</td></tr><tr><td align="center">date</td><td align="center">建立日期</td><td align="center">文件建立日期</td></tr><tr><td align="center">updated</td><td align="center">更新日期</td><td align="center">文件更新日期</td></tr><tr><td align="center">comments</td><td align="center">开启文章的评论功能</td><td align="center">true</td></tr><tr><td align="center">tags</td><td align="center">标签（不适用于分页）</td><td align="center"></td></tr><tr><td align="center">categories</td><td align="center">分类（不适用于分页）</td><td align="center"></td></tr><tr><td align="center">permalink</td><td align="center">覆盖文章网址</td><td align="center"></td></tr></tbody></table><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo 提供了很多现成的<a href="https://hexo.io/themes/">主题</a>供大家选择,大家选择自己喜欢的即可，这里选择<a href="https://github.com/probberechts/hexo-theme-cactus/blob/master/README.md">cactus</a>-一款比较经典的 hexo 主题演示：</p><p>在项目根目录 clone 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/probberechts/hexo-theme-cactus.git themes/cactus</span><br></pre></td></tr></table></figure><p>在_config.yml 中配置博客的主题即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">cactus</span></span><br></pre></td></tr></table></figure><p>重新 hexo server 后可以看到新的主题了：</p><p><img src="/assets/20200915-blog/img3.png" alt="image-20200911172630511"></p><p><img src="/assets/20200915-blog/img4.png" alt="image-20200911172630511"></p><p>自定义顶部导航信息<br>默认主题会提供以下导航信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">Home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">About:</span> <span class="string">/about/</span></span><br><span class="line">  <span class="attr">Writing:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="attr">Projects:</span> <span class="string">http://github.com/probberechts</span></span><br></pre></td></tr></table></figure><p>如果我们要增加只要在下面增加一个变量，配置一下路由即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span> <span class="string">...</span></span><br><span class="line">  <span class="string">haha:/</span></span><br></pre></td></tr></table></figure><p><img src="/assets/20200915-blog/img5.png" alt="image-20200911172630511"></p><p>添加<a href="https://tongji.baidu.com/">百度统计</a>,按照指引开通绑定项目：然后修改配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fill in your Baidu Analytics tracking ID to enable Baidu Analytics.</span></span><br><span class="line"><span class="attr">baidu_analytics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">2e6da3c375c8a87f5b664cexxx</span> <span class="comment"># id=百度统计为应用分配的id</span></span><br></pre></td></tr></table></figure><p>添加评论系统</p><p>本教程使用的是<a href="https://valine.js.org/quickstart.html">valine</a>-一款无需登录、配置方便的评论系统；</p><p>先<a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a>或<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a> <code>LeanCloud</code>, 进入<a href="https://leancloud.cn/dashboard/applist.html#/apps">控制台</a>后点击左下角<a href="https://leancloud.cn/dashboard/applist.html#/newapp">创建应用</a>：</p><p><img src="/assets/20200915-blog/img6.webp" alt="image-20200911172630511"></p><p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了：</p><p><img src="/assets/20200915-blog/img7.webp" alt="image-20200911172630511"></p><p>添加配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">0AQiakktufEkOkBGRTG7OMOA-xxx</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="string">K7A8Rj80r3C59gYyLjJ9Bxxx</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment">#邮件提醒设置</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment">#验证码设置</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">ヾﾉ≧∀≦)o快来评论一下吧!</span> <span class="comment">#placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="comment">#头像设置</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后进入主题的 layout=&gt;_partial=&gt;comments.ejs，加入以下代码，使其支持评论系统</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%if</span> (<span class="attr">theme.valine.app_id</span> &amp;&amp; <span class="attr">theme.valine.app_key</span>) &#123;%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/valine/dist/Valine.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;script src=&quot;//cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;script src=&#x27;//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js&#x27;&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vcomments&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> notify = &lt;%= theme.valine.notify %&gt; == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> verify = &lt;%= theme.valine.verify %&gt; == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> visitor = &lt;%= theme.valine.visitor %&gt; == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#vcomments&#x27;</span>,</span></span><br><span class="line">              notify: notify,</span><br><span class="line">              verify: verify,</span><br><span class="line"><span class="javascript">      app_id: <span class="string">&#x27;&lt;%= theme.valine.app_id %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    app_key: <span class="string">&#x27;&lt;%= theme.valine.app_key %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          lang: <span class="string">&#x27;en&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          placeholder: <span class="string">&#x27;&lt;%= theme.valine.placeholder %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          avatar: <span class="string">&#x27;&lt;%= theme.valine.avatar %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">          pageSize: <span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.valine.pageSize</span> %&gt;</span>,</span></span></span><br><span class="line">          visitor: visitor</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125;%&gt;</span></span><br></pre></td></tr></table></figure><p>添加完最终长这样：</p><p><img src="/assets/20200915-blog/img8.webp" alt="image-20200911172630511"></p><p>添加<a href="https://github.com/wzpan/hexo-generator-search"><u><em>站内搜索</em></u></a>以及<a href="https://github.com/hexojs/hexo-generator-feed"><u><em>RSS</em></u></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在主题配置文件中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="string">other</span> <span class="string">code</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">/search/</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure><p>在根配置中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p><img src="/assets/20200915-blog/img9.webp" alt="image-20200911172630511"></p><p>添加<a href="https://github.com/purplemysticx/hexo-pwa.git">PWA</a>支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-pwa</span><br></pre></td></tr></table></figure><p>在根配置中添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pwa:</span></span><br><span class="line">  <span class="attr">manifest:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/manifest.json</span> <span class="comment"># PWA配置文件</span></span><br><span class="line">    <span class="attr">body:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">辰总的blog</span></span><br><span class="line">      <span class="attr">short_name:</span> <span class="string">辰总的blog</span></span><br><span class="line">      <span class="attr">icons:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">src:</span> <span class="string">/assets/avatar.jpeg</span> <span class="comment"># 头像地址</span></span><br><span class="line">          <span class="attr">sizes:</span> <span class="string">192x192</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">image/png</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">src:</span> <span class="string">/assets/avatar.jpeg</span></span><br><span class="line">          <span class="attr">sizes:</span> <span class="string">512x512</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">image/png</span></span><br><span class="line">      <span class="attr">start_url:</span> <span class="string">/index.html</span> <span class="comment"># 启动页面</span></span><br><span class="line">      <span class="attr">theme_color:</span> <span class="string">&quot;#000000&quot;</span></span><br><span class="line">      <span class="attr">background_color:</span> <span class="string">&quot;#000000&quot;</span> <span class="comment"># 添加到本地后背景颜色</span></span><br><span class="line">      <span class="attr">display:</span> <span class="string">standalone</span></span><br><span class="line">  <span class="attr">serviceWorker:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/sw.js</span> <span class="comment"># serviceWorker地址</span></span><br><span class="line">    <span class="attr">preload:</span></span><br><span class="line">      <span class="attr">urls:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">posts:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">opts:</span></span><br><span class="line">      <span class="attr">networkTimeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="type">!!js/regexp</span> <span class="string">/hm.baidu.com/</span></span><br><span class="line">        <span class="attr">strategy:</span> <span class="string">networkOnly</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="type">!!js/regexp</span> <span class="string">/.*\.(js|css|jpg|jpeg|png|gif)$/</span></span><br><span class="line">        <span class="attr">strategy:</span> <span class="string">cacheFirst</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="type">!!js/regexp</span> <span class="string">/\//</span></span><br><span class="line">        <span class="attr">strategy:</span> <span class="string">networkFirst</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>最终展现为<br><img src="/assets/20200915-blog/img10.webp" alt="image-20200911172630511"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="guthub-page"><a href="#guthub-page" class="headerlink" title="guthub page"></a>guthub page</h3><p>在根配置中修改部署地址信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&quot;git&quot;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&quot;https://github.com/YOMXXX/YOMXXX.github.io&quot;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy</span><br></pre></td></tr></table></figure><p>稍等几分钟，我们可以看到部署成功了</p><p><img src="/assets/20200915-blog/img15.png" alt="image-20200911172630511"></p><p>然后直接访问线上地址：<a href="https://github.com/YOMXXX/YOMXXX.github.io">https://github.com/YOMXXX/YOMXXX.github.io</a></p><h3 id="腾讯云-Serverless-Framework（https-console-cloud-tencent-com-sls）"><a href="#腾讯云-Serverless-Framework（https-console-cloud-tencent-com-sls）" class="headerlink" title="腾讯云 Serverless Framework（https://console.cloud.tencent.com/sls）"></a>腾讯云 Serverless Framework（<a href="https://console.cloud.tencent.com/sls%EF%BC%89">https://console.cloud.tencent.com/sls）</a></h3><blockquote><p>Serverless Framework 是业界非常受欢迎的无服务器应用框架，开发者无需关心底层资源即可部署完整可用的 Serverless 应用架构。Serverless Framework 具有资源编排、自动伸缩、事件驱动等能力，覆盖编码、调试、测试、部署等全生命周期，帮助开发者通过联动云资源，迅速构建 Serverless 应用。</p></blockquote><p><a href="https://cloud.tencent.com/document/product/1154">文档地址</a></p><p>首先开通服务，然后创建一个项目=&gt;选择快速部署一个 Vue 项目；</p><p><img src="/assets/20200915-blog/img11.png" alt="image-20200911172630511"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ npm install -g serverless</span><br><span class="line">$ serverless init vue-starter --name my-vue.js-app</span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">$ <span class="built_in">cd</span> my-vue.js-app &amp;&amp; serverless deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建完成后把项目中的这两个文件粘贴到博客项目的根目录中</p><p><img src="/assets/20200915-blog/img13.png" alt="image-20200911172630511"></p><p>serverless.yml 是部署到腾讯云的配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">component:</span> <span class="string">website</span></span><br><span class="line"><span class="attr">org:</span> <span class="string">&quot;Tencent Cloud, Inc.&quot;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&quot;辰总&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">个人博客，技术文章，生活随笔，记录优秀的文章</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&quot;个人博客，技术文章，生活随笔，记录优秀的文章&quot;</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">&quot;https://github.com/serverless-components/tencent-vue-starter&quot;</span></span><br><span class="line"><span class="attr">readme:</span> <span class="string">&quot;https://github.com/serverless-components/tencent-vue-starter/master/README.md&quot;</span></span><br><span class="line"><span class="attr">license:</span> <span class="string">MIT</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">pro</span> <span class="comment"># (可选) 用于区分环境信息，默认值是 dev</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line">  <span class="attr">src:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">./</span> <span class="comment"># 打包的根路径</span></span><br><span class="line">    <span class="attr">hook:</span> <span class="string">sudo</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">sudo</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">&amp;&amp;</span> <span class="string">sudo</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span> <span class="comment"># 打包前执行的钩子script</span></span><br><span class="line">    <span class="attr">dist:</span> <span class="string">./public</span> <span class="comment"># 打包的目录</span></span><br><span class="line"><span class="attr">src:</span></span><br><span class="line">  <span class="attr">src:</span> <span class="string">./</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.env</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.git/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;**/node_modules&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;**/package-lock.json&quot;</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">辰总的Blog</span></span><br></pre></td></tr></table></figure><p>然后执行 serverless deploy 稍等几分钟我们可以看到上传成功了</p><p><img src="/assets/20200915-blog/img14.png" alt="image-20200911172630511"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> serverless </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1搭建舒适的docker前端开发环境</title>
      <link href="/2020/11/20/20201120-docker-web/"/>
      <url>/2020/11/20/20201120-docker-web/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文意在使用 docker 帮助前端同学搭建<code>统一的前端开发环境</code>—解决因为不同的开发环境（mac、windows、linux）导致的各种依赖相关或者运行中丢失某些文件的问题；</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>docker docker-compose node nginx 以及前端的项目（vue 项目）</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote><p>首先全局安装<a href="https://www.docker.com/get-started">docker 客户端</a>以 mac 系统为例；</p></blockquote><p>看到这个就代表安装成功了</p><p><img src="/assets/20201120-docker/img1.png"></p><p><img src="/assets/20201120-docker/img2.png"></p><p>打开 docker 设置找到 docker engine 配置一下国内代理加速</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;features&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;buildkit&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>, <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/20201120-docker/img3.jpg"></p><p>安装 vscode 的 Docker 插件-用于帮助我们管理我们的 docker 镜像以及容器等；</p><p><img src="/assets/20201120-docker/img11.png"></p><p>下面初始化一个 vue 项目作为 demo（vue-cli）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-docker</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>在项目根目录中创建一个名为 Dockerfile 的文件，用于 docker 相关的配置；</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置构建的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="comment">#创建一个名为vue-docker的文件夹</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  mkdir -p  /vue-docker</span></span><br><span class="line"><span class="comment">#进入到这个目录中（当我们打开镜像终端的时候会自动进入这个目录中去）</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /vue-docker</span></span><br><span class="line"><span class="comment">#拷贝当前目录下所有东西到vue-docker目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="comment">#设置npm下载依赖来源为淘宝源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span></span><br><span class="line"><span class="comment">#安装项目依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i</span></span><br><span class="line"><span class="comment">#在启动镜像时执行启动项目的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> npm run serve</span></span><br><span class="line"><span class="comment">#暴露端口用于外部访问</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在根目录中执行构建命令<br>-t: 设置容器的名称<br>.:是打包当前目录所有东西（不包括.dockerignore 中的文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t vue-docker .</span><br></pre></td></tr></table></figure><p>构建过程长这样<br><img src="/assets/20201120-docker/img4.jpg"></p><p>构建完成后我们可以查看构建后的镜像列表<br><img src="/assets/20201120-docker/img5.jpg"></p><p>然后我们执行 run 命令去启动一个容器<br>-d: 后台运行<br>-p: 映射容器内的 8080 端口到主机的 8080 端口<br>-i: 交互式操作<br>-t: 终端<br>-v: 文件映射，将主机本地的文件映射到容器中，这样我们本地修改文件内容，可以动态看到页面的变化了<br>vue-docker: 这是指用 vue-docker 镜像为基础来启动容器<br>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -v /src:/vue-docker/src vue-docker</span><br><span class="line"><span class="comment"># 进入命令行</span></span><br><span class="line">docker run -it vue-docker /bin/bash</span><br></pre></td></tr></table></figure><p>然后看到 af28efc278be5ae44f83511522cfb375a6f6811b573c33565c22ab087b415d90 这个说明容器已经启动了</p><p><img src="/assets/20201120-docker/img6.jpg"></p><p>我们打开浏览器访问<code>http://localhost:8080</code>，就能看到页面内容了，本地代码更改，页面也会随之改变</p><p><img src="/assets/20201120-docker/img7.jpg"></p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>目前仅仅是启动了一个 vue 的服务，我们如果想使用其他服务怎么呢？比如我们想使用 node 做中间层，使用 nginx 转发的代理怎么办呢（当然我们可以使用 webpack—proxy 去做代理）？</p><p>有的同学可能会这样写</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /home/work/app/nginx/conf/nginx.conf</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /home/work/app/nginx/sbin/nginx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  mkdir -p  /vue-docker</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /vue-docker</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> npm run serve</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在一个 Dockerfile 文件中并不会把两个 from 一起构建，最终构建的还是带有 node 环境的镜像;</p><p>为了解决这个问题我们需要引入 docker-compose，去一起构建我们所需环境的依赖的镜像；</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.16.1&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><p>看到这个说明安装成功了</p><p><img src="/assets/20201120-docker/img8.png"></p><p>然后我们需要编写 docker-compose 的配置文件了，在项目跟目录中创建一个名为 docker-compose.yml 的文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span> <span class="comment"># 指定版本(不同的版本存在语法差异，这边使用最新的版本)</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">nginx:</span> <span class="comment"># 用户自定义的服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span> <span class="comment"># 使用的nginx最新的镜像</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/default.conf:/etc/nginx/conf.d/default.conf</span> <span class="comment"># 拷贝default.conf目录到容器里的</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span> <span class="comment"># 暴露端口用于外部访问</span></span><br><span class="line">  <span class="attr">vue:</span> <span class="comment"># 用户自定义的服务名称</span></span><br><span class="line">    <span class="attr">build:</span> <span class="comment"># 构建相关的配置 也可以直接使用image:xxx去构建</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">vue</span> <span class="comment"># 使用dockerfile配置的文件名</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/vue-docker</span> <span class="comment"># 进入工作的目录中</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">serve</span> <span class="comment"># 在启动镜像时执行启动项目的命令</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 指定映射的路径（可指定多个）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./x&#x27;x&#x27;x:/xxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/src:/vue-docker/src</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 暴露端口用于外部访问（可指定多个）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br></pre></td></tr></table></figure><p>接下来在项目跟目录中创建 default.conf，用于 nginx 相关的配置；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">       <span class="attr">proxy_pass</span> <span class="string">http://vuedocker:8080; # 这里的vueDocker就是docker-compose中自定义的services名</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span></span><br><span class="line">    <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">        <span class="attr">root</span>   <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来在项目跟目录中创建 vue 文件，用于 Dockerfile 相关的配置；</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置构建的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node</span><br><span class="line"><span class="comment">#创建一个名为vue-docker的文件夹</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  mkdir -p  /vue-docker</span></span><br><span class="line"><span class="comment">#进入到这个目录中（当我们打开镜像终端的时候会自动进入这个目录中去）</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /vue-docker</span></span><br><span class="line"><span class="comment">#拷贝当前目录下所有东西到vue-docker目录中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="comment">#设置npm下载依赖来源为淘宝源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span></span><br><span class="line"><span class="comment">#安装项目依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm i</span></span><br><span class="line"><span class="comment">#在启动镜像时执行启动项目的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> npm run serve</span></span><br><span class="line"><span class="comment">#暴露端口用于外部访问</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>然后 vue.config.js 中添加 disableHostCheck，不去检测域名；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着执行 docker-compose -d up 指令启动 docker-compose 构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d: 后台执行</span></span><br><span class="line">docker-compose -d up</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到绿色的箭头说明我们的容器全都启动了，然后访问<code>http://localhost</code> 就可以看到页面了</p><p><img src="/assets/20201120-docker/img10.png"></p><p><img src="/assets/20201120-docker/img9.png"></p><h1 id="下期主题—Dockerfile-的多阶段构建"><a href="#下期主题—Dockerfile-的多阶段构建" class="headerlink" title="下期主题—Dockerfile 的多阶段构建"></a>下期主题—Dockerfile 的多阶段构建</h1>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序云开发基础实战</title>
      <link href="/2020/09/11/20200911-yun/"/>
      <url>/2020/09/11/20200911-yun/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 serverless 越来越火，基本大厂都使用云开发的技术，使自己的业务托管上云，开发者则大多把重心关注在业务的开发上，无需关注扩容等操作，一切交给云服务商即可，大大减少了开发部署等操作，而对于小程序云开发，开发者完全可以作为全栈工程师去开发项目（包括前端、后端、数据库-mongodb 等），无需搭建服务器，即可使用云端能力；云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥；</p><table><thead><tr><th align="center">能力</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">云函数</td><td align="center">无需自建服务器</td><td align="center">在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码</td></tr><tr><td align="center">数据库</td><td align="center">无需自建数据库</td><td align="center">一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库</td></tr><tr><td align="center">存储</td><td align="center">无需自建存储和 CDN</td><td align="center">在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理</td></tr><tr><td align="center">云调用</td><td align="center">原生微信服务集成</td><td align="center">基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力</td></tr></tbody></table><h2 id="1-新建云开发模板"><a href="#1-新建云开发模板" class="headerlink" title="1. 新建云开发模板"></a>1. 新建云开发模板</h2><blockquote><p>也可以省略此步骤，直接在已有项目上开通和使用云开发。</p></blockquote><p>新建项目选择一个空目录，填入 AppID（使用云开发能力必须填写 AppID），勾选创建 “云开发 QuickStart 项目”，点击创建即可得到一个展示云开发基础能力的示例小程序。该小程序与普通 QuickStart 小程序有以下不同需注意：</p><ul><li>无游客模式、也不可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/sandbox.html">测试号</a></li><li><code>project.config.json</code> 中增加了字段 <code>cloudfunctionRoot</code> 用于指定存放云函数的目录</li><li><code>cloudfunctionRoot</code> 指定的目录有特殊的图标</li><li>云开发能力从基础库 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.2.3</a> 开始支持（覆盖率 97.3%，查看<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference/compatibility.html">兼容性问题</a>）</li></ul><p>从基础库 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.4.1</a> 开始，在小程序插件中可以使用云开发，插件中使用云开发时，使用的是插件方的云资源而非宿主的云资源，在使用方式上与在小程序中使用无异。</p><h2 id="2-开通云开发、创建环境"><a href="#2-开通云开发、创建环境" class="headerlink" title="2. 开通云开发、创建环境"></a>2. 开通云开发、创建环境</h2><p>创建了第一个云开发小程序后，在使用云开发能力之前需要先开通云开发。在开发者工具工具栏左侧，点击 “云开发” 按钮即可打开云控制台、根据提示开通云开发、创建云环境。默认配额下可以创建两个环境，各个环境相互隔离，每个环境都包含独立的数据库实例、存储空间、云函数配置等资源。每个环境都有唯一的环境 ID 标识，初始创建的环境自动成为默认环境。</p><blockquote><p>注：AppID 首次开通云环境后，需等待大约 10 分钟方可正常使用云 API，在此期间官方后台服务正在做准备服务，如尝试在小程序中调用云 API 则会报 <code>cloud init error：&#123; errMsg: &quot;invalid scope&quot; &#125;</code> 的错误</p></blockquote><p>完成后我们就能看到控制台信息了<br><img src="/assets/20200911-yun/img1.png" alt="image-20200911172630511"></p><p>接着在 project.config.json 文件中配置云函数存放的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;cloudfunctionRoot&quot;</span>: <span class="string">&quot;cloudfunctions/&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>配置完后，在开发者工具中会出现当前环境的标示，这样就配置成功了；<br><img src="/assets/20200911-yun/img2.png" alt="image-20200911172630511"></p><p>然后在 app.js 中配置云开发的初始化方法:其中 env 为当前云开发的环境，不指定的话则默认为第一个创建的环境</p><ul><li>注： 我们可以根据小程序开发环境的不同，去动态映射云开发的环境；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wx.cloud) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&quot;请使用 2.2.3 或以上的基础库以使用云能力&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wx.cloud.init(&#123;</span><br><span class="line">        <span class="comment">// env 参数说明：</span></span><br><span class="line">        <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">        <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">        <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">        <span class="comment">// env: &#x27;my-env-id&#x27;,</span></span><br><span class="line">        traceUser: <span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-体验云开发"><a href="#3-体验云开发" class="headerlink" title="3. 体验云开发"></a>3. 体验云开发</h2><h3 id="3-1-常量-DYNAMIC-CURRENT-ENV"><a href="#3-1-常量-DYNAMIC-CURRENT-ENV" class="headerlink" title="3.1 常量 DYNAMIC_CURRENT_ENV"></a>3.1 常量 DYNAMIC_CURRENT_ENV</h3><blockquote><p>支持端：云函数 <a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference/changelog-server-sdk.html">1.1.0</a></p></blockquote><p>标志当前所在环境，注意该值不是当前所在环境 ID 的字符串，其值等价于 <code>Symbol.for(&#39;DYNAMIC_CURRENT_ENV&#39;)</code>，是用于标志当前所在环境的。如在 <code>init</code> 中如果给 <code>env</code> 参数传该常量值，则后续的 API 请求会自动请求当前所在环境的云资源，如云函数 A 当前所在环境是 <code>test-123</code>，则其接下来请求数据库、文件存储、云函数时都默认请求环境 <code>test-123</code> 的数据库、文件存储、云函数。</p><p>常量可用于：</p><ul><li><code>cloud.init</code> 的 <code>env</code> 参数</li><li><code>cloud.updateConfig</code> 的 <code>env</code> 参数</li><li>各 API 的 <code>config</code> 参数中的 <code>env</code> 参数</li></ul><p>注意事项：</p><ul><li><p>自 <code>1.7.1</code> 起，该变量支持在定时触发器中使用，之前的版本不支持。<br><strong>cloud.database: 设置新数据库对象的调用环境等于当前所在环境</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">  env: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同于 init 时设置的环境，db 对象的请求将会去到和当前云函数所在环境相同的环境</span></span><br><span class="line"><span class="keyword">const</span> db = cloud.database(&#123;</span><br><span class="line">  env: cloud.DYNAMIC_CURRENT_ENV,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-云数据库"><a href="#3-2-云数据库" class="headerlink" title="3.2 云数据库"></a>3.2 云数据库</h3><p>云数据库底层使用的是 mongodb，对于前端同学也不是很陌生；小程序调用数据库比较方便，可以直接在小程序 js 文件中调用（不像 uni-app 中，一定要在云函数中才能使用，比较恶心！）；<br>首先按照下图先创建一个集合，作为测试我已经创建了一个名为 test 的集合<br><img src="/assets/20200911-yun/img3.png" alt="image-20200911172630511"></p><p>下面代码中，我们 onload 回调中我们向刚刚创建的 test 集合中添加了一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> db =  wx.cloud.database()</span><br><span class="line">  <span class="keyword">await</span> db.collection(<span class="string">&#x27;test&#x27;</span>).add(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      config: &#123;</span><br><span class="line">        env: <span class="string">&#x27;test-123&#x27;</span> <span class="comment">// 环境 ID，指定使用哪个环境下的对应的云函数，填写后将忽略 init 时指定的环境 ID，这里将访问test-123云空间的test集合，然后添加一条数据</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们刷新控制台就能看到刚刚添加的数据啦<br><img src="/assets/20200911-yun/img4.png" alt="image-20200911172630511"></p><p>其他常用的方法，见<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/Cloud.database.html">官方文档</a></p><h3 id="3-2-云函数"><a href="#3-2-云函数" class="headerlink" title="3.2 云函数"></a>3.2 云函数</h3><p>在云函数中使用 wx-server-sdk，需先调用初始化方法 init 一次，init 用于设置接下来在该云函数实例中调用云函数、数据库、文件存储时要访问的环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&quot;wx-server-sdk&quot;</span>);</span><br><span class="line">cloud.init(&#123;</span><br><span class="line">  env: <span class="string">&quot;test-x1dzi&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们调用云函数test的时候，访问的就是test-x1dzi这个云空间里的资源了</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="keyword">await</span> wx.cloud.callFunction(&#123;</span><br><span class="line">  name: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-云开发实战-模糊图像高清处理"><a href="#4-云开发实战-模糊图像高清处理" class="headerlink" title="4 云开发实战-模糊图像高清处理"></a>4 云开发实战-模糊图像高清处理</h2><h3 id="4-1-目的"><a href="#4-1-目的" class="headerlink" title="4.1 目的"></a>4.1 目的</h3><p>解决模糊图片带来的不好体验，利用 AI 图片处理使其变高清；</p><h3 id="4-2-技术栈"><a href="#4-2-技术栈" class="headerlink" title="4.2 技术栈"></a>4.2 技术栈</h3><p>腾讯云 AI 图片处理 API、云调用、云函数、云储存</p><h3 id="4-3-开发"><a href="#4-3-开发" class="headerlink" title="4.3 开发"></a>4.3 开发</h3><p>1.申请开通腾讯云图像处理工作台；<br><img src="/assets/20200911-yun/img5.png" alt="image-20200911172630511"></p><p>2.开通完，等几分钟就可以看到控制台了；</p><p><img src="/assets/20200911-yun/img6.png" alt="image-20200911172630511"></p><p>3.然后点击后上角的<a href="https://console.cloud.tencent.com/api/explorer?Product=tiia&Version=2019-05-29&Action=EnhanceImage&SignVersion=">接口文档</a></p><p>4.可以看到系统为你生成了一套代码，不过我们需要添加<a href="https://console.cloud.tencent.com/cam/capi">SecretId、SecretKey</a>，ImageUrl 为图片地址可以接受线上地址或者 Base64 地址，这个我们一会动态传递即可，返回的值是一个 base64 的地址；</p><p><img src="/assets/20200911-yun/img7.png" alt="image-20200911172630511"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tencentcloud = <span class="built_in">require</span>(<span class="string">&quot;tencentcloud-sdk-nodejs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TiiaClient = tencentcloud.tiia.v20190529.Client;</span><br><span class="line"><span class="keyword">const</span> models = tencentcloud.tiia.v20190529.Models;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Credential = tencentcloud.common.Credential;</span><br><span class="line"><span class="keyword">const</span> ClientProfile = tencentcloud.common.ClientProfile;</span><br><span class="line"><span class="keyword">const</span> HttpProfile = tencentcloud.common.HttpProfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cred = <span class="keyword">new</span> Credential(<span class="string">&quot;AKIDrjxxxxxx&quot;</span>, <span class="string">&quot;iBRUIq5ssssss&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> httpProfile = <span class="keyword">new</span> HttpProfile();</span><br><span class="line">httpProfile.endpoint = <span class="string">&quot;tiia.tencentcloudapi.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> clientProfile = <span class="keyword">new</span> ClientProfile();</span><br><span class="line">clientProfile.httpProfile = httpProfile;</span><br><span class="line"><span class="keyword">let</span> client = <span class="keyword">new</span> TiiaClient(cred, <span class="string">&quot;ap-beijing&quot;</span>, clientProfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req = <span class="keyword">new</span> models.EnhanceImageRequest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> params = <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line">req.from_json_string(params);</span><br><span class="line"></span><br><span class="line">client.EnhanceImage(req, <span class="function"><span class="keyword">function</span>(<span class="params">errMsg, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (errMsg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(errMsg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(response.to_json_string());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5.然后我们需要把上面的代码放到云函数中，托管代码，然后前端去调用，首先创建一个新的云函数；</p><p><img src="/assets/20200911-yun/img8.png" alt="image-20200911172630511"></p><p>6.把代码粘贴到 index.js 中，稍加修改，用云函数包一下即可；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> tencentcloud = <span class="built_in">require</span>(<span class="string">&quot;tencentcloud-sdk-nodejs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&quot;wx-server-sdk&quot;</span>);</span><br><span class="line">cloud.init(&#123;</span><br><span class="line">  <span class="comment">// API 调用都保持和云函数当前所在环境一致</span></span><br><span class="line">  env: cloud.DYNAMIC_CURRENT_ENV,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> TiiaClient = tencentcloud.tiia.v20190529.Client;</span><br><span class="line">  <span class="keyword">const</span> models = tencentcloud.tiia.v20190529.Models;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Credential = tencentcloud.common.Credential;</span><br><span class="line">  <span class="keyword">const</span> ClientProfile = tencentcloud.common.ClientProfile;</span><br><span class="line">  <span class="keyword">const</span> HttpProfile = tencentcloud.common.HttpProfile;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cred = <span class="keyword">new</span> Credential(<span class="string">&quot;AKIDrjxxxxxx&quot;</span>, <span class="string">&quot;iBRUIq5ssssss&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> httpProfile = <span class="keyword">new</span> HttpProfile();</span><br><span class="line">  httpProfile.endpoint = <span class="string">&quot;tiia.tencentcloudapi.com&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> clientProfile = <span class="keyword">new</span> ClientProfile();</span><br><span class="line">  clientProfile.httpProfile = httpProfile;</span><br><span class="line">  <span class="keyword">let</span> client = <span class="keyword">new</span> TiiaClient(cred, <span class="string">&quot;ap-beijing&quot;</span>, clientProfile);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> req = <span class="keyword">new</span> models.EnhanceImageRequest();</span><br><span class="line">  <span class="keyword">const</span> fileList = event.fileID; <span class="comment">// event=是我们传递的参数的对象集合，fileID是我们传递的参数名</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> params = <span class="string">&#x27;&#123;&quot;ImageUrl&quot;:&quot;https://www.google.com/imgres?imgurl=https%3A%2F%2Fimg.iplaysoft.com%2Fwp-content%2Fuploads%2F2019%2Ffree-images%2Ffree_stock_photo.jpg&amp;imgrefurl=https%3A%2F%2Fwww.iplaysoft.com%2Ffree-images.html&amp;tbnid=vQjlM9KtkGsb_M&amp;vet=12ahUKEwiY9Zfn3-frAhVG15QKHeudABMQMygAegUIARCeAQ..i&amp;docid=JeaDEV9l4RQZhM&amp;w=680&amp;h=453&amp;q=%E5%9B%BE%E7%89%87&amp;ved=2ahUKEwiY9Zfn3-frAhVG15QKHeudABMQMygAegUIARCeAQ&quot;&#125;&#x27;</span>;</span><br><span class="line">  req.from_json_string(params);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      client.EnhanceImage(req, <span class="function"><span class="keyword">function</span>(<span class="params">errMsg, response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (errMsg) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(errMsg);</span><br><span class="line">          resolve(errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(response.to_json_string());</span><br><span class="line">        resolve(response.EnhancedImage);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    result: <span class="keyword">await</span> run(),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>7.我们把代码粘贴到 index.js 中，然后开启本地调试，可以看到生成了 base64 地址，说明转换成功了<br><img src="/assets/20200911-yun/img9.png" alt="image-20200911172630511"></p><p>8.接下来我们需要把写死的图片通过前端传递过去，而且图片需要从本地选择，又图片转换功能不支持本地图片转换，需要线上地址，故用到了小程序端-云储存上传、云函数端-云储存下载；</p><!-- // 目前图片地址是写死的 需要做成动态获取 --><p>流程： 前端选择图片=&gt;把本地图片上传到云储存=&gt;调用云函数传递云储存传递 fileID=&gt;云函数调用云储存拿到真实线上地址=&gt;调用 AI 接口=&gt;返回转换后的地址给前端=&gt;前端展示</p><ol><li>前端选择图片</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseImage(&#123;</span><br><span class="line">  count: <span class="number">1</span>,</span><br><span class="line">  sizeType: [<span class="string">&quot;compressed&quot;</span>],</span><br><span class="line">  sourceType: [<span class="string">&quot;album&quot;</span>],</span><br><span class="line">  success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class="line">    <span class="keyword">const</span> tempFilePaths = res.tempFilePaths;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      ImageUrl: tempFilePaths[<span class="number">0</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>把本地图片上传到云储存&amp;调用云函数传递云储存传递 fileID</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.uploadFile(&#123;</span><br><span class="line">  cloudPath: rdm + <span class="string">&quot;.png&quot;</span>, <span class="comment">//云储存的文件名</span></span><br><span class="line">  filePath: <span class="built_in">this</span>.data.ImageUrl, <span class="comment">// 文件路径</span></span><br><span class="line">  success: <span class="keyword">async</span> (res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="keyword">await</span> wx.cloud.callFunction(&#123;</span><br><span class="line">      name: <span class="string">&quot;Upload&quot;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        fileID: [res.fileID],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      img: <span class="string">&quot;data:image/png;base64,&quot;</span> + msg.result.result,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>云函数调用云储存拿到真实线上地址=&gt;调用 AI 接口=&gt;返回转换后的地址给前端</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileList = event.fileID;</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> cloud.getTempFileURL(&#123;</span><br><span class="line">  fileList: fileList,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> params = <span class="string">&#x27;&#123;&quot;ImageUrl&quot;:&quot;&#x27;</span> + result.fileList[<span class="number">0</span>].tempFileURL + <span class="string">&#x27;&quot;&#125;&#x27;</span>;</span><br><span class="line">req.from_json_string(params);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    client.EnhanceImage(req, <span class="function"><span class="keyword">function</span>(<span class="params">errMsg, response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (errMsg) &#123;</span><br><span class="line">        resolve(errMsg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(response.to_json_string());</span><br><span class="line">      resolve(response.EnhancedImage);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  result: <span class="keyword">await</span> run(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>最终展示视频如下</p><video id="video" controls="" preload>  <source id="mp4" src="/assets/20200911-yun/mp4.mp4" type="video/mp4" /></video></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
          <category> serverless </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>web3.js编译Solidity</title>
      <link href="/2020/09/04/20200904-web3/"/>
      <url>/2020/09/04/20200904-web3/</url>
      
        <content type="html"><![CDATA[<h1 id="web3-js-编译-Solidity，发布，调用全部流程（手把手教程）"><a href="#web3-js-编译-Solidity，发布，调用全部流程（手把手教程）" class="headerlink" title="web3.js 编译 Solidity，发布，调用全部流程（手把手教程）"></a>web3.js 编译 Solidity，发布，调用全部流程（手把手教程）</h1><p>下面教程是打算在尽量牵涉可能少的以太坊的相关工具，主要使用 web3.js 这个以太坊提供的工具包，来完成合约的编译，发布，合约方法调用的一整个流程。一方面来了解以太坊开发到底需要什么，另一方面来对 web3.js 的 API 有个基本的了解。由于所有其它工具都或多或少的是对 web3.js 的底层函数的包装，所以对 web3.js 使用流程有个认识之后，也能更好的入门，使用相关的工具。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1-1-安装-Node-js"><a href="#1-1-安装-Node-js" class="headerlink" title="1.1 安装 Node.js"></a>1.1 安装 Node.js</h3><p>由于我们要使用 web3.js<a href="https://web3.tryblockchain.org/web3-js-in-action.html#fn1">1</a>。这里使用 Node 来集成 web3.js 模块（当然，你还可以使用其它的方式）。你可以通过参考官网文档安装<a href="https://web3.tryblockchain.org/web3-js-in-action.html#fn2">2</a>。</p><h4 id="1-1-1-Ubuntu"><a href="#1-1-1-Ubuntu" class="headerlink" title="1.1.1 Ubuntu"></a>1.1.1 Ubuntu</h4><p>如果你使用 ubuntu，可以使用下述命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装Node</span></span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line"><span class="comment">//安装Node的包管理器</span></span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><h4 id="1-1-2-MAC"><a href="#1-1-2-MAC" class="headerlink" title="1.1.2 MAC"></a>1.1.2 MAC</h4><p>如果你使用<code>Homebrew</code>，可以使用下述命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装Node</span></span><br><span class="line">brew install node</span><br><span class="line"><span class="comment">//安装Node的包管理器</span></span><br><span class="line">brew install npm</span><br></pre></td></tr></table></figure><h4 id="1-1-3-安装检查"><a href="#1-1-3-安装检查" class="headerlink" title="1.1.3 安装检查"></a>1.1.3 安装检查</h4><p>安装成功后，可以查看下当前的版本，确认正常安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v7<span class="number">.2</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="1-2-以太坊的节点"><a href="#1-2-以太坊的节点" class="headerlink" title="1.2 以太坊的节点"></a>1.2 以太坊的节点</h3><p>由于整个合约代码的执行需要一个虚拟机环境，所以在开始之前，我们不得不安装一个实现了以太坊虚拟机的节点。</p><p>可以选择一个轻量级的节点，比如<code>EtherumJS TestRPC</code>，它是一个完整的在内存中的区块链仅仅存在于你开发的设备上。它在执行交易时是实时返回，而不等待默认的出块时间，这样你可以快速验证你新写的代码，当出现错误时，也能即时反馈给你。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ethereumjs-testrpc</span><br></pre></td></tr></table></figure><p>安装好后，你就可以通过<code>testrpc</code>命令来启动了，启动与大多数以太坊节点一样，运行在<code>localhost:8545</code>。</p><p>如果你安装<code>geth</code>这样的客户端也是可以的。</p><h3 id="1-3-Web3-的支持"><a href="#1-3-Web3-的支持" class="headerlink" title="1.3 Web3 的支持"></a>1.3 Web3 的支持</h3><p>安装<code>web3</code>的模块[web3]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3</span><br></pre></td></tr></table></figure><h2 id="2-合约编译"><a href="#2-合约编译" class="headerlink" title="2. 合约编译"></a>2. 合约编译</h2><h3 id="2-1-一个简单的合约"><a href="#2-1-一个简单的合约" class="headerlink" title="2.1 一个简单的合约"></a>2.1 一个简单的合约</h3><p>我们打算用来测试的合约如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Calc&#123;</span><br><span class="line">  <span class="comment">/*区块链存储*/</span></span><br><span class="line">  uint count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*执行会写入数据，所以需要`transaction`的方式执行。*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint a, uint b</span>) <span class="title">returns</span>(<span class="params">uint</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*执行不会写入数据，所以允许`call`的方式执行。*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCount</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add()</code>方法用来返回输入两个数据的和，并会对<code>add()</code>方法的调用次数进行计数。需要注意的是这个计数是存在区块链上的，对它的调用需要使用<code>transaction</code>。</p><p><code>getCount()</code>返回<code>add()</code>函数的调用次数。由于这个函数不会修改区块链的任何状态，对它的调用使用<code>call</code>就可以了。</p><h3 id="2-2-编译合约"><a href="#2-2-编译合约" class="headerlink" title="2.2 编译合约"></a>2.2 编译合约</h3><p>由于合约是使用<code>Solidity</code>编写，所以我们可以使用<code>web3.eth.compile.solidity</code>来编译合约<a href="https://web3.tryblockchain.org/web3-js-in-action.html#fn3">3</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译合约</span></span><br><span class="line"><span class="keyword">let</span> source = <span class="string">&quot;pragma solidity ^0.4.0;contract Calc&#123;  /*区块链存储*/  uint count;  /*执行会写入数据，所以需要`transaction`的方式执行。*/  function add(uint a, uint b) returns(uint)&#123;    count++;    return a + b;  &#125;  /*执行不会写入数据，所以允许`call`的方式执行。*/  function getCount() returns (uint)&#123;    return count;  &#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calc = web3.eth.compile.solidity(source);</span><br></pre></td></tr></table></figure><p>如果编译成功，结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: <span class="string">&#x27;0x606060405234610000575b607e806100176000396000f3606060405260e060020a6000350463771602f781146026578063a87d942c146048575b6000565b3460005760366004356024356064565b60408051918252519081900360200190f35b3460005760366077565b60408051918252519081900360200190f35b6000805460010190558181015b92915050565b6000545b9056&#x27;</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        source: <span class="string">&#x27;pragma solidity ^0.4.0;contract Calc&#123;  /*区块链存储*/  uint count;  /*执行会写入数据，所以需要`transaction`的方式执行。*/  function add(uint a, uint b) returns(uint)&#123;    count++;    return a + b;  &#125;  /*执行不会写入数据，所以允许`call`的方式执行。*/  function getCount() returns (uint)&#123;    return count;  &#125;&#125;&#x27;</span>,</span><br><span class="line">        language: <span class="string">&#x27;Solidity&#x27;</span>,</span><br><span class="line">        languageVersion: <span class="string">&#x27;0.4.6+commit.2dabbdf0.Emscripten.clang&#x27;</span>,</span><br><span class="line">        compilerVersion: <span class="string">&#x27;0.4.6+commit.2dabbdf0.Emscripten.clang&#x27;</span>,</span><br><span class="line">        abiDefinition: [</span><br><span class="line">            [</span><br><span class="line">                <span class="built_in">Object</span></span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                <span class="built_in">Object</span></span><br><span class="line">            ]</span><br><span class="line">        ],</span><br><span class="line">        userDoc: &#123;</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        developerDoc: &#123;</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-发布合约"><a href="#3-发布合约" class="headerlink" title="3. 发布合约"></a>3. 发布合约</h2><p><code>web3.js</code>其实也像框架一样对合约的操作进行了封装。发布合约时，可以使用<code>web3.eth.contract</code>的<code>new</code>方法<a href="https://web3.tryblockchain.org/web3-js-in-action.html#fn4">4</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myContractReturned = calcContract.new(&#123;</span><br><span class="line">    data: deployCode,</span><br><span class="line">    <span class="keyword">from</span>: deployeAddr</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, myContract</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">// 注意：这个回调会触发两次</span></span><br><span class="line">        <span class="comment">//一次是合约的交易哈希属性完成</span></span><br><span class="line">        <span class="comment">//另一次是在某个地址上完成部署</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断是否有地址，来确认是第一次调用，还是第二次调用。</span></span><br><span class="line">        <span class="keyword">if</span> (!myContract.address) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;contract deploy transaction hash: &quot;</span> + myContract.transactionHash) <span class="comment">//部署合约的交易哈希值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合约发布成功</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>部署过程中需要主要的是，<code>new</code>方法的回调会执行两次，第一次是合约的交易创建完成，第二次是在某个地址上完成部署。需要注意的是只有在部署完成后，才能进行方法该用，否则会报错<code>TypeError: myContractReturned.add is not a function</code>。</p><h2 id="4-调用合约"><a href="#4-调用合约" class="headerlink" title="4. 调用合约"></a>4. 调用合约</h2><p>由于<code>web3.js</code>封装了合约调用的方法。我们可以使用可以使用<code>web3.eth.contract</code>的里的<code>sendTransaction</code>来修改区块链数据。在这里有个坑，有可能会出现<code>Error: invalid address</code>，原因是没有传<code>from</code>，交易发起者的地址。在使用<code>web3.js</code>的 API 都需留意，出现这种找不到地址的，都看看<code>from字段吧。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用transaction方式调用，写入到区块链上</span></span><br><span class="line">myContract.add.sendTransaction(<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">  <span class="keyword">from</span>: deployeAddr,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after contract deploy, call:&quot;</span> + myContract.getCount.call());</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要修改区块链上的数据，一定要使用<code>sendTransaction</code>，这会消耗<code>gas</code>。如果不修改区块链上的数据，使用<code>call</code>，这样不会消耗<code>gas</code>。</p><h2 id="5-使用-web3-js-编译，发布，调用的完整源码"><a href="#5-使用-web3-js-编译，发布，调用的完整源码" class="headerlink" title="5. 使用 web3.js 编译，发布，调用的完整源码"></a>5. 使用 web3.js 编译，发布，调用的完整源码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Web3 = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> web3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://localhost:8545&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">from</span> = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译合约</span></span><br><span class="line"><span class="keyword">let</span> source = <span class="string">&quot;pragma solidity ^0.4.0;contract Calc&#123;  /*区块链存储*/  uint count;  /*执行会写入数据，所以需要`transaction`的方式执行。*/  function add(uint a, uint b) returns(uint)&#123;    count++;    return a + b;  &#125;  /*执行不会写入数据，所以允许`call`的方式执行。*/  function getCount() constant returns (uint)&#123;    return count;  &#125;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> calcCompiled = web3.eth.compile.solidity(source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calcCompiled);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;ABI definition:&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(calcCompiled[<span class="string">&quot;info&quot;</span>][<span class="string">&quot;abiDefinition&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到合约对象</span></span><br><span class="line"><span class="keyword">let</span> abiDefinition = calcCompiled[<span class="string">&quot;info&quot;</span>][<span class="string">&quot;abiDefinition&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> calcContract = web3.eth.contract(abiDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 部署合约</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1 获取合约的代码，部署时传递的就是合约编译后的二进制码</span></span><br><span class="line"><span class="keyword">let</span> deployCode = calcCompiled[<span class="string">&quot;code&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 部署者的地址，当前取默认账户的第一个地址。</span></span><br><span class="line"><span class="keyword">let</span> deployeAddr = web3.eth.accounts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 异步方式，部署合约</span></span><br><span class="line"><span class="keyword">let</span> myContractReturned = calcContract.new(</span><br><span class="line">  &#123;</span><br><span class="line">    data: deployCode,</span><br><span class="line">    <span class="keyword">from</span>: deployeAddr,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, myContract</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">      <span class="comment">// 注意：这个回调会触发两次</span></span><br><span class="line">      <span class="comment">//一次是合约的交易哈希属性完成</span></span><br><span class="line">      <span class="comment">//另一次是在某个地址上完成部署</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过判断是否有地址，来确认是第一次调用，还是第二次调用。</span></span><br><span class="line">      <span class="keyword">if</span> (!myContract.address) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;contract deploy transaction hash: &quot;</span> + myContract.transactionHash); <span class="comment">//部署合约的交易哈希值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合约发布成功后，才能调用后续的方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;contract deploy address: &quot;</span> + myContract.address); <span class="comment">// 合约的部署地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用transaction方式调用，写入到区块链上</span></span><br><span class="line">        myContract.add.sendTransaction(<span class="number">1</span>, <span class="number">2</span>, &#123;</span><br><span class="line">          <span class="keyword">from</span>: deployeAddr,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;after contract deploy, call:&quot;</span> + myContract.getCount.call());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 函数返回对象`myContractReturned`和回调函数对象`myContract`是 &quot;myContractReturned&quot; === &quot;myContract&quot;,</span></span><br><span class="line">      <span class="comment">// 所以最终`myContractReturned`这个对象里面的合约地址属性也会被设置。</span></span><br><span class="line">      <span class="comment">// `myContractReturned`一开始返回的结果是没有设置的。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，异步执行，此时还是没有地址的。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;returned deployed didn&#x27;t have address now: &quot;</span> + myContractReturned.address);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用非回调的方式来拿到返回的地址，但你需要等待一段时间，直到有地址，建议使用上面的回调方式。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">setTimeout(function()&#123;</span></span><br><span class="line"><span class="comment">  console.log(&quot;returned deployed wait to have address: &quot; + myContractReturned.address);</span></span><br><span class="line"><span class="comment">  console.log(myContractReturned.getCount.call());</span></span><br><span class="line"><span class="comment">&#125;, 20000);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你在其它地方已经部署了合约，你可以使用at来拿到合约对象</span></span><br><span class="line"><span class="comment">//calcContract.at([&quot;0x50023f33f3a58adc2469fc46e67966b01d9105c4&quot;]);</span></span><br></pre></td></tr></table></figure><p><a href="https://me.tryblockchain.org/">原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 以太坊 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小程序错误统计</title>
      <link href="/2020/09/03/20200903-feishu-bug-collection/"/>
      <url>/2020/09/03/20200903-feishu-bug-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>解决线上报错难以归类、查找的问题，根据每位同学负责的项目的不同，单独分类并解决 bug，提升用户体验，以及小程序的评分等；</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>抓取微信后台报错=&gt;根据不同的人负责项目的不同分别统计=&gt;生成 excel=&gt;上传到飞书文档</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>node（superagent、xlsx）+ 飞书文档</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><ul><li>首先登陆<a href="https://mp.weixin.qq.com/">微信公众平台</a>中的开发一栏；</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img1.png"></p><ul><li>选择页面里面的运维中心=&gt;错误查询选项；</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img2.png"></p><ul><li>页面长这样，我们可以选择里面日期，版本，类型等条件进行查询；</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img3.png"></p><ul><li>然后打开 chrome 的控制台，点击查询按钮, 我们可以看到请求了一个接口，这个接口微信用于查询错误的接口了，也是我们要用的接口</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img4.png"></p><p><img src="/assets/20200903-feishu-bug-collection/img5.png"></p><p><img src="/assets/20200903-feishu-bug-collection/img6.png"></p><ul><li>下面我们要做的就是把上边所有的请求头参数粘贴出来拟微信请求了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">&quot;superagent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configs = &#123;</span><br><span class="line">  Accept: <span class="string">&quot;application/json, text/plain,&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line">  Connection: <span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;96&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">  Cookie: <span class="string">&quot;xxxxxxxxxxx&quot;</span>,</span><br><span class="line">  Host: <span class="string">&quot;mp.weixin.qq.com&quot;</span>,</span><br><span class="line">  Origin: <span class="string">&quot;https://mp.weixin.qq.com&quot;</span>,</span><br><span class="line">  Referer: <span class="string">&quot;https://mp.weixin.qq.com/wxamp/wxaalarm/get_jserr?token=730361255&amp;lang=zh_CN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;empty&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.113 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runBug</span>(<span class="params">pageNum = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> superagent</span><br><span class="line">    .post(<span class="string">`https://mp.weixin.qq.com/wxamp/cgi/route?path=xxx&amp;token=xxx&amp;lang=zh_CN&amp;random=<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// 请求所携带的参数</span></span><br><span class="line">    <span class="comment">// start_time 开始时间</span></span><br><span class="line">    <span class="comment">// end_time 结束时间</span></span><br><span class="line">    <span class="comment">// start 页数时间</span></span><br><span class="line">    <span class="comment">// limit 每页条数</span></span><br><span class="line">    .send(&#123; <span class="attr">errmsg_keyword</span>: <span class="string">&quot;&quot;</span>, <span class="attr">type</span>: <span class="number">1</span>, <span class="attr">client_version</span>: <span class="string">&quot;&quot;</span>, <span class="attr">start_time</span>: process.argv[<span class="number">2</span>], <span class="attr">end_time</span>: process.argv[<span class="number">3</span>], <span class="attr">start</span>: pageNum, <span class="attr">limit</span>: <span class="number">5</span> &#125;)</span><br><span class="line">    .set(<span class="string">&quot;Cookie&quot;</span>, configs[<span class="string">&quot;Cookie&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Host&quot;</span>, configs[<span class="string">&quot;Host&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Origin&quot;</span>, configs[<span class="string">&quot;Origin&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Sec-Fetch-Dest&quot;</span>, configs[<span class="string">&quot;Sec-Fetch-Dest&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Sec-Fetch-Mode&quot;</span>, configs[<span class="string">&quot;Sec-Fetch-Mode&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Sec-Fetch-Site&quot;</span>, configs[<span class="string">&quot;Sec-Fetch-Site&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;User-Agent&quot;</span>, configs[<span class="string">&quot;User-Agent&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Accept&quot;</span>, configs[<span class="string">&quot;Accept&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Accept-Encoding&quot;</span>, configs[<span class="string">&quot;Accept-Encoding&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Accept-Language&quot;</span>, configs[<span class="string">&quot;Accept-Language&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Connection&quot;</span>, configs[<span class="string">&quot;Connection&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Content-Length&quot;</span>, configs[<span class="string">&quot;Content-Length&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Content-Type&quot;</span>, configs[<span class="string">&quot;Content-Type&quot;</span>])</span><br><span class="line">    .set(<span class="string">&quot;Referer&quot;</span>, configs[<span class="string">&quot;Referer&quot;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后可以看到接口请求成功了！</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img7.png"></p><ul><li>接下来要做的就是根据每位同学负责的项目单独查找报错信息，并生成 excel（每位同学一个 sheet,如果某个报错不属于任何一个人的话，直接放到其他中）,这里就使用到了<a href="https://www.npmjs.com/package/xlsx">xlsx</a>了，根绝</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> XLSX = <span class="built_in">require</span>(<span class="string">&quot;xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//excel里的sheet第一行</span></span><br><span class="line"><span class="keyword">const</span> basic = [<span class="string">&quot;时间&quot;</span>, <span class="string">&quot;客户端版本&quot;</span>, <span class="string">&quot;小程序版本&quot;</span>, <span class="string">&quot;版本错误次数&quot;</span>, <span class="string">&quot;总错误次数&quot;</span>, <span class="string">&quot;错误内容&quot;</span>, <span class="string">&quot;备注（有特殊情况的，说明具体原因！）&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    pages: [<span class="string">&quot;pages/a1&quot;</span>, <span class="string">&quot;pages/a2&quot;</span>], <span class="comment">// 页面路由</span></span><br><span class="line">    result: [basic], <span class="comment">// 匹配集合</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    pages: [<span class="string">&quot;pages/b1&quot;</span>, <span class="string">&quot;pages/b2&quot;</span>],</span><br><span class="line">    result: [basic]</span><br><span class="line">  &#125;</span><br><span class="line">  其他: &#123; <span class="attr">result</span>: [basic] &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runBug</span>(<span class="params">pageNum = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = 接口返回的数据</span><br><span class="line">  <span class="keyword">if</span> (res.body.results &amp;&amp; res.body.results.length) &#123;</span><br><span class="line">    <span class="comment">// 遍历报错信息集合</span></span><br><span class="line">    results: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.body.results.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 遍历成员集合</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> w = <span class="number">0</span>; w &lt; memberKey.length - <span class="number">1</span>; w++) &#123;</span><br><span class="line">        <span class="comment">// 遍历成员的路由</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; member[memberKey[w]].pages.length; v++) &#123;</span><br><span class="line">          <span class="comment">// 判断报错信息与成员负责的页面路由是否匹配</span></span><br><span class="line">          <span class="keyword">if</span> (res.body.results[i].errmsg.indexOf(member[memberKey[w]].pages[v]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            member[memberKey[w]].result.push([format(res.body.results[i].time), res.body.results[i].client_version, res.body.results[i].app_version, res.body.results[i].version_error_cnt, res.body.results[i].total_error_cnt, res.body.results[i].errmsg]);</span><br><span class="line">            <span class="keyword">continue</span> results;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 没有匹配上任何成员的路由，则默认放到“其他”sheet下面，统一管理</span></span><br><span class="line">      member[<span class="string">&quot;其他&quot;</span>].result.push([format(res.body.results[i].time), res.body.results[i].client_version, res.body.results[i].app_version, res.body.results[i].version_error_cnt, res.body.results[i].total_error_cnt, res.body.results[i].errmsg], <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    runBug(++pageNum); <span class="comment">// 当前页面查询完毕，接着查询下一页，直到没有内容位置</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> wb = XLSX.utils.book_new();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; memberKey.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> ws = XLSX.utils.aoa_to_sheet(member[memberKey[i]].result);</span><br><span class="line">        XLSX.utils.book_append_sheet(wb, ws, memberKey[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">await</span> XLSX.writeFile(wb, <span class="string">`<span class="subst">$&#123;format(+process.argv[<span class="number">2</span>]) + <span class="string">&quot;-&quot;</span> + format(+process.argv[<span class="number">3</span>]) + <span class="string">&quot;错误统计&quot;</span>&#125;</span>.xlsx`</span>); <span class="comment">// 生成excel文件到当前目录中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们打开 excel，这就是我们想要的</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img8.png"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ul><li>目前的开发设计在本地，发给每个人去更改，然后在反馈统计，显然是不太合理;我想要的是多人在线协作更改，实时反馈，目前有两个解决方案；<ul><li><u> 1、通过飞书开放平台提供的<a href="https://open.f.mioffice.cn/document/ukTMukTMukTM/uADN14CM0UjLwQTN">api</a>上传(不过目前公司搭建的飞书服务这个方法不能使用了，我也不知道为啥~~) </u></li><li><u> 2、通过飞书客户端手动上传，此方法简单直接点击选择就行了 </u></li></ul></li></ul><p><img src="/assets/20200903-feishu-bug-collection/img9.png"></p><p><img src="/assets/20200903-feishu-bug-collection/img10.png"></p><ul><li>上传后，结构是乱的，我们需要手动转为在线表格才行</li></ul><p><img src="/assets/20200903-feishu-bug-collection/img11.png"></p><ul><li>这样就是我们最终想要的最终结果啦<del>~</del></li></ul><p><img src="/assets/20200903-feishu-bug-collection/img12.png"></p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 飞书文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞书机器人--前端文章推送</title>
      <link href="/2020/09/02/20200902-feishu-robot/"/>
      <url>/2020/09/02/20200902-feishu-robot/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>每日推送新鲜的前端学习资料，供大家阅读、学习等；</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>node（superagent、cheerio 等）+ 腾讯云云函数</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p><em>注：如果是自己公司搭建的飞书私服的话，则需要按照私服的文档进行开发即可</em></p><ul><li>进入飞书开发平台<a href="https://open.feishu.cn/">我的应用</a>中申请注册一个 APP，然后系统会给分配一个 appid 以及 appsecret 用于后续校验、认证逻辑；</li></ul><p><img src="/assets/20200902-robot/img1.png"></p><ul><li>在飞书群聊中添加所创建的机器人；</li></ul><p><img src="/assets/20200902-robot/img2.png"></p><ul><li>打开飞书开发平台<a href="https://open.feishu.cn/document/ukTMukTMukTM/uIjNz4iM2MjLyYzM">服务端 API</a>，去获取应用的 tenant_access_token，用作 APP 的认证标识(所有请求都需要此标识作为认证依据)；</li></ul><p><img src="/assets/20200902-robot/img3.png"></p><ul><li>获取所有添加机器人的群列表，用于指定群发送信息；</li></ul><p><img src="/assets/20200902-robot/img4.png"></p><ul><li>准备工作完成后，可以开始发送消息推送了，我这边选择的是发送富文本消息的模式，因为发送种类多，功能强大；</li></ul><p><img src="/assets/20200902-robot/img5.png"></p><ul><li>发送到群里的消息大致长这样：因为目前是测试，不是真实数据，下面会用到真实数据；</li></ul><p><img src="/assets/20200902-robot/img6.png"></p><h2 id="爬虫（接口、页面）"><a href="#爬虫（接口、页面）" class="headerlink" title="爬虫（接口、页面）"></a>爬虫（接口、页面）</h2><p>上面已经实现了消息的推送，但是数据是假的，日常工作中我们肯定想要阅读高质量、标准的文章，所以要拿到好的数据源，这边选择的是<a href="https://web-api.juejin.im/query">掘金的 API</a>作为数据源；使用<a href="https://www.npmjs.com/package/superagent">superagent</a>爬取接口数据，使用<a href="https://www.npmjs.com/package/cheerio">cheerio</a>爬取页面数据，最终展示的效果为：</p><p><img src="/assets/20200902-robot/img7.png"></p><p><img src="/assets/20200902-robot/img8.png"></p><h2 id="部署（腾讯云云函数）"><a href="#部署（腾讯云云函数）" class="headerlink" title="部署（腾讯云云函数）"></a>部署（腾讯云云函数）</h2><p><u>目前代码只是运行在本地，这样肯定不行，需要跑在服务器中，而且我的需求是每天早晚需要推送一次，这就要用到定时任务了，所以我这边选择了腾讯云云函数部署，依托了腾讯云，我们只需要关注代码的开发，方便、快捷且收费很便宜;</u></p><p><img src="/assets/20200902-robot/img9.png"></p><p><img src="/assets/20200902-robot/img10.png"></p><ul><li>我这边选择的是 node8.9、空白模板，当然也可以选择更高的版本以及不同语言的模板函数；</li></ul><p><img src="/assets/20200902-robot/img11.png"></p><p><img src="/assets/20200902-robot/img12.png"></p><ul><li>传建完成后：</li></ul><p><img src="/assets/20200902-robot/img13.png"></p><ul><li>我们可以在线编辑代码或者选择 zip 上传代码：</li></ul><p><img src="/assets/20200902-robot/img14.png"></p><p><u>注：这边需要注意的是我们的代码执行逻辑必须包含在 index.main_handler 这个函数中（当然也可以自定义函数名哈），且最后执行的结果必须返回一个 promise 对象，不然云函数不能识别；</u></p><ul><li><p>上传完后点击保存，就搞定了；</p></li><li><p>最后点击触发信息添加定时任务</p></li></ul><p><img src="/assets/20200902-robot/img15.png"></p><ul><li>我选择的是自定义触发任务，因为我想 9 点半触发一次，定时任务的语法使用的是 cron 表达式，最后点击提交即可；</li></ul><p><img src="/assets/20200902-robot/img16.png"></p><p><img src="/assets/20200902-robot/img17.png"></p><p>可以看到每天 9 点半准时推送了！</p><p><img src="/assets/20200902-robot/img18.png"></p><p>到此我们的开发就完成了！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了上述通过调用接口的方式发送推送外，飞书还提供了 Webhook（网络钩子）的方式发送推送，不过功能过于单一，不太好用；</p><p><img src="/assets/20200902-robot/img19.png"></p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> serverless </tag>
            
            <tag> serverless（云函数） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Composition API 陷阱</title>
      <link href="/2020/09/01/20200901-Composition-API/"/>
      <url>/2020/09/01/20200901-Composition-API/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从 React Hooks 出现之后，批评的声音不断，很多人说它带来了心智负担，因为相比传统的 Class 写法，useState/useEffect 的依赖于执行顺序的特点让人捉摸不透。与此相对的，在 Vue3 Composition API RFC 中，我们看到 Vue3 官方描述 CompositionAPI 是一个基于已有的”响应式”心智模型的更好方案，这让我们觉得好像不需要任何心智模型的切换就可以迅速投入到 Compositoin API 的开发中去。但在我尝试了一段时间后，发现事实并非如此，我们依然需要一些思维上的变化来适应新的 Compsition API。</p><h2 id="Setup-陷阱"><a href="#Setup-陷阱" class="headerlink" title="Setup 陷阱"></a>Setup 陷阱</h2><h3 id="简单陷阱"><a href="#简单陷阱" class="headerlink" title="简单陷阱"></a>简单陷阱</h3><p>先看一个 Vue2 简单例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;count&#125;&#125;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;addCount&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt; <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     count: <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">   addCount() &#123;</span><br><span class="line">     <span class="built_in">this</span>.count += <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 Vue2 的心智模型中，我们总会在 data 中返回一个对象，我们并不关心对象的值是简单类型还是引用类型，因为它们都能很好的被响应式系统处理，就像上面这个例子一样。但是，如果我们不作任何心智模型的变化，就开始使用 Composition API，我们就容易写出这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   &#123;&#123;count&#125;&#125;</span><br><span class="line">   &lt;button @click=<span class="string">&quot;addCount&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">   <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">     count: <span class="number">0</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     data.count += <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     count: data.count,</span><br><span class="line">     addCount</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>实际上，这段代码不能正常运作，当你点击 button 时，视图不会响应数据变化。原因是，我们先将 data 中的 count 取了出来，再合并到 this.$data 中，但是一旦 count 被取出来，它就是一个单纯的简单类型数据，响应式就丢了。</p><h3 id="复杂陷阱"><a href="#复杂陷阱" class="headerlink" title="复杂陷阱"></a>复杂陷阱</h3><p>数据结构越复杂，我们就越容易落入陷阱，在这里我们把一段业务逻辑抽离到自定义 hooks 里，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">   userInfo: &#123;</span><br><span class="line">     name: <span class="string">&#x27;default_name&#x27;</span>,</span><br><span class="line">     role: <span class="string">&#x27;default_role&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   projectList: []</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 异步获取数据</span></span><br><span class="line">   fetch(...).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; userInfo, projectList &#125; = result</span><br><span class="line">     data.userInfo = userInfo</span><br><span class="line">     data.projectList = projectList</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后像往常一样，我们在业务组件中去使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &#123;&#123;name&#125;&#125;</span><br><span class="line">   &#123;&#123;role&#125;&#125;</span><br><span class="line">   &#123;&#123;list&#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt; <span class="keyword">import</span> useSomeData <span class="keyword">from</span> <span class="string">&#x27;./useSomeData&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; userInfo, projectList &#125; = useSomeData()</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     name: userInfo.name <span class="comment">// 响应式断掉</span></span><br><span class="line">     role: userInfo.role, <span class="comment">// 响应式断掉</span></span><br><span class="line">     list: projectList <span class="comment">// 响应式还是断掉</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们看到，不管我们从响应式数据里取出什么（简单类型 or 引用类型），都会导致响应式断掉，进而无法更新视图。</p><p>所有这些问题的根源都是：<strong>setup 只会执行一次。</strong></p><h2 id="迁移到新的心智模型"><a href="#迁移到新的心智模型" class="headerlink" title="迁移到新的心智模型"></a>迁移到新的心智模型</h2><ol><li>时刻记住 setup 只会执行一次</li><li>永远不要直接使用简单类型</li><li>解构可能有风险，优先使用引用本身，而不是解构它</li><li>可以通过一些手段让解构变得安全</li></ol><h3 id="使用新心智模型来解决问题"><a href="#使用新心智模型来解决问题" class="headerlink" title="使用新心智模型来解决问题"></a>使用新心智模型来解决问题</h3><p>简单陷阱：永远不要直接使用简单类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   &#123;&#123;count&#125;&#125;</span><br><span class="line">   &lt;button @click=<span class="string">&quot;addCount&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt; <span class="keyword">import</span> &#123; reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">   <span class="keyword">const</span> count = ref(<span class="number">0</span>) <span class="comment">// 在这里使用ref包裹一层引用容器</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     count.value += <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     count,</span><br><span class="line">     addCount</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>复杂陷阱-方案 1：解构可能有风险，优先使用引用本身，而不是解构它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &#123;&#123;someData.userInfo.name&#125;&#125;</span><br><span class="line">   &#123;&#123;someData.userInfo.role&#125;&#125;</span><br><span class="line">   &#123;&#123;someData.projectList&#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt; <span class="keyword">import</span> useSomeData <span class="keyword">from</span> <span class="string">&#x27;./useSomeData&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">   <span class="keyword">const</span> someData = useSomeData()</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     someData</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>复杂陷阱-方案 2：可以通过 computed 让解构变得安全</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, onMounted, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">   userInfo: &#123;</span><br><span class="line">     name: <span class="string">&#x27;default_user&#x27;</span>,</span><br><span class="line">     role: <span class="string">&#x27;default_role&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   projectList: []</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 异步获取数据</span></span><br><span class="line">   fetch(...).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; userInfo, projectList &#125; = result</span><br><span class="line">     data.userInfo = userInfo</span><br><span class="line">     data.projectList = projectList</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> userName = computed(<span class="function">() =&gt;</span> data.userInfo.name)</span><br><span class="line"> <span class="keyword">const</span> userRole = computed(<span class="function">() =&gt;</span> data.userinfo.role)</span><br><span class="line"> <span class="keyword">const</span> projectList = computed(<span class="function">() =&gt;</span> data.projectList)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   userName,</span><br><span class="line">   userRole,</span><br><span class="line">   projectList</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; userName, userRole, projectList &#125; = useSomeData()</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     name: userName <span class="comment">// 是计算属性，响应式不会断掉</span></span><br><span class="line">     role: userRole, <span class="comment">// 是计算属性，响应式不会断掉</span></span><br><span class="line">     list: projectList <span class="comment">// 是计算属性，响应式不会断掉</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂陷阱-方案 3：方案 2 需要额外写一些 computed 属性，比较麻烦，我们还可以通过 toRefs 让解构变得安全</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">   userInfo: &#123;</span><br><span class="line">     name: <span class="string">&#x27;default_user&#x27;</span>,</span><br><span class="line">     role: <span class="string">&#x27;default_role&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   projectList: []</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 异步获取数据</span></span><br><span class="line">   fetch(...).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; userInfo, projectList &#125; = result</span><br><span class="line">     data.userInfo = userInfo</span><br><span class="line">     data.projectList = projectList</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="comment">// 使用toRefs</span></span><br><span class="line"> <span class="keyword">return</span> toRefs(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 现在userInfo和projectList都已经被ref包裹了一层</span></span><br><span class="line">    <span class="comment">// 这层包裹会在template中自动解开</span></span><br><span class="line">    <span class="keyword">const</span> &#123; userInfo, projectList &#125; = useSomeData();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: userInfo.value.name, <span class="comment">// ???好了吗</span></span><br><span class="line">      role: userInfo.value.role, <span class="comment">// ???好了吗</span></span><br><span class="line">      list: projectList, <span class="comment">// ???好了吗</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你以为这样就好了吗？其实这里有一个<strong>陷阱中的陷阱</strong>：projectList 好了，但是 name 和 role 依然是响应式断开的状态，因为 toRefs 只会”浅“包裹，实际上 useSomeData 返回的结果是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someData = useSomeData()</span><br><span class="line">↓</span><br><span class="line">&#123;</span><br><span class="line"> userInfo: &#123;</span><br><span class="line">   value: &#123;</span><br><span class="line">     name: <span class="string">&#x27;...&#x27;</span>, <span class="comment">// 依然是简单类型，没有被包裹</span></span><br><span class="line">     role: <span class="string">&#x27;...&#x27;</span> <span class="comment">// 依然是简单类型，没有被包裹</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> projectList: &#123;</span><br><span class="line">   value: [...]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们的 useSomeData 如果想要通过 toRefs 实现真正的解构安全，需要这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 让每一层级都套一层ref</span></span><br><span class="line"> <span class="keyword">return</span> toRefs(&#123;</span><br><span class="line">   projectList: data.projectList,</span><br><span class="line">   userInfo: toRefs(data.userInfo)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建议：使用自定义 hooks 返回数据的时候，如果数据的层级比较简单，可以直接使用 toRefs 包裹；如果数据的层级比较复杂，建议使用 computed。</p></blockquote><h2 id="绕过陷阱"><a href="#绕过陷阱" class="headerlink" title="绕过陷阱"></a>绕过陷阱</h2><p>上述操作其实是 Vue 官方使用 CompositionAPI 的标准方式，因为 CompositionAPI 完全就是按照 setup 只会执行一次进行设计的。但是不可否认的是，这的确带来了许多心智负担，因为我们不得不时刻关注响应式数据到底能不能解构，不然一不小心就容易调到坑里。</p><p>其实所有这些问题都出在 setup 只会执行一次，那么有没有办法解决呢？有的，可以使用 JSX 或 h 的写法，绕过 setup 只会执行一次的问题：</p><p>还是这个存在安全隐患的自定义 hooks：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useSomeData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">   userInfo: &#123;</span><br><span class="line">     name: <span class="string">&#x27;default_name&#x27;</span>,</span><br><span class="line">     role: <span class="string">&#x27;default_role&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   projectList: []</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 异步获取数据</span></span><br><span class="line">   fetch(...).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; userInfo, projectList &#125; = result</span><br><span class="line">     data.userInfo = userInfo</span><br><span class="line">     data.projectList = projectList</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-JSX-或-h"><a href="#使用-JSX-或-h" class="headerlink" title="使用 JSX 或 h"></a>使用 JSX 或 h</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useSomeData <span class="keyword">from</span> <span class="string">&quot;./useSomeData&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> someData = useSomeData();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        userInfo: &#123; name, role &#125;,</span><br><span class="line">        projectList,</span><br><span class="line">      &#125; = someData;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;name&#125;</span><br><span class="line">          &#123;role&#125;</span><br><span class="line">          &#123;projectList&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用 JSX 或 h 的时候，setup 需要返回一个函数，这个函数其实就是 render 函数，它在数据变化时会重新执行，所以我们只需要把解构的逻辑放到 render 函数里，那么就解决了 setup 只会执行一次的问题。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我们可能需要一些约定，来约束自定义 hooks 的使用方式。但是官方并没有给出，这将导致我们 hooks 会写的五花八门，并且漏洞百出。目前来看，”不要解构“是最安全的方式。</p><p>我专门就这个问题请教了 yyx 大佬，大佬给出了一个”约定”，那就是尽量少使用“解构”。这我也很无奈。其实我是希望官方能够给出一个工具，让我们减少在自定义 hooks 中犯错误的可能性。（toRefs 其实就是这样的一个工具，但是它并不能解决所有问题）</p><p><a href="https://juejin.im/post/6855473771013226503">原文连接</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> Compsition API </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
